#-------------------------------------------------------------------------------
#
#   IDA Pro Plug-in: Dynamic Data Resolver (DDR) Front End
#
#   Version 0.1 alpha
#
#   Copyright (C) 2019 Cisco Talos
#   Author: Holger Unterbrink (hunterbr@cisco.com)
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#   Requirements
#   ------------
#   Requests    (http://docs.python-requests.org)       # on IDA machine
#   Flask       (http://flask.pocoo.org/)               # only on ddr_server.py machine
#   PyOpenSSL   (https://pyopenssl.org/en/stable/)      # only on ddr_server.py machine
#
#   e.g.
#   pip install -U requests
#   pip install -U Flask
#   pip install -U pyOpenSSL
#
#   Hint: Make sure you install these requirements for the same Python version IDA is using. 
# 
#
#   Installation
#   ------------
#   Drag and drop ddr_plugin.py into IDA Pro's plugin folder for IDA Pro 7.x and higher
#   e.g. C:\Program Files\IDA 7.x\plugins 
#
#   Copy ddr_server.py to a remote PC where you want to run the malware sample
#   against the DynamoRIO DDR client.
#
#   The IDA ddr_plugin.py is the frontend for the ddr_server which executes the 
#   DynamoRio DDR client (ddr.dll) to instrument and analyse the malware sample
#
#   It is highly recommended to run the ddr_server.py on a different PC.
#   WARNING: Keep in mind the DynamoRio client is executing the sample !!!
#
#   Make sure you change the WEBSERVER variable below, so the ddr_plugin knows 
#   where to find the ddr_server.
#
#
#   Common setup:
#   -------------
#
#   Analyst PC (IDA, ddr_plugin.py) 
#              | 
#              | IP network
#              |
#              | IP addr = [WEBSERVER/WEBSERVER_PORT variable]
#   Malware PC (DynamoRio, ddr.dll, ddr_server.py, sample.exe)
#                [ SERVER_LOCAL_SAMPLE_DIR = Folder to copy sample file to] 
#
#
# ToDo: 
#   - Automatically copy sample file from IDA to DDRserver.py side
#   - Implement feature in DDR.dll to only log calls/jmps details
#   - Kill Dynrio client after time x to fight sleepers 
#   - Improve imput checks for user provided data
# 
#-----------------------------------------------------------------------------------

import idaapi
import idautils
import idc
import logging
import tempfile
import os
import glob
import errno
import json
import inspect
import subprocess
import requests
import zipfile
from datetime import datetime
from PyQt5 import QtCore, QtGui, QtWidgets
from collections import Counter, OrderedDict

###############################################################################################################################
#                                                   User settings                                                             #
###############################################################################################################################
#
# IP address of host ddr_server.py is running on
WEBSERVER                   = "192.168.100.122"     
# Port DDRserver.py is using                    
WEBSERVER_PORT              = "5000"  
# API key, check ddr_server.py start messages                                                                  
DDR_WEBAPI_KEY              = "KT5LUFCHHSO12986OPZTWEFS"  # gets generated by the ddr_server.py script, check its output.
# CA certificate
CA_CERT                     = "C:\\Users\\Dex Dexter\\Documents\\idaplugin\\ddr_server.crt"   
# Verify certificates
VERIFY_CERT                 = True
# Directory on the machine ddr_server.py is running on. The location where the server can find the sample to analyse    
# Make sure you escape '\' in the directory name e.g. "C:\\Users\\Some User\\malware_dir"                      
SERVER_LOCAL_SAMPLE_DIR     = "C:\\Users\\Dex Dexter\\Documents\\DDR_samples\\" 

########################## Usually you do not need to change anything below this line ###################################

# Max. timeout the ddr_server.py has for answering in seconds, before we kill the request.
# Don't set this too low, it should be long enough to run the DynamoRio client analysis.
MAX_API_TIMEOUT             = 30.0                                
# Debug Level, the higher the more is printed to the IDA log window. See DDR_print_mesg() for details.     
DBG_LEVEL                   = 2  
# Default max. number of instructions to execute before Dynamorio stops logging.                                 
MAX_INSTR_TO_EXECUTE        = 20000      
# Default max. number of found instruction values added to the IDA log window (max. 50, see below).                         
MAX_LOG_ROUNDS              = 5 
# Default max. number of found instruction values added to the IDA DISASM view as comments (max. 50, see below).                                  
MAX_CMT_ROUNDS              = 3 
# Max. number of instruction addresses wich will be added to the trace_instr_num_list list.  
# This list holds all the occurences of instruction numbers which match the ea address.    
# This is the max value for the MAX_LOG_ROUNDS and MAX_CMT_ROUNDS variables.                            
MAX_INSTR_COUNT             = 50                                  

# Colors used for highlighting the building blocks. If you want to change this, change the assignment to COLOR1-5 below.                                          			 
GREEN  			= [0xa0ffa0, 0x70ff70, 0x00ff00, 0x00ef00, 0x00df00, 0x00cf00, 0x00bf00, 0x00af00]   	
YELLOW 			= [0xd0ffff, 0xa0ffff, 0x70ffff, 0x00ffff, 0x00efff, 0x00dfff, 0x00cfff, 0x00bfff]		
RED    			= [0xC0C0ff, 0xB0B0ff, 0xA0A0ff, 0x8080ff, 0x6060ff, 0x4040ff, 0x2020ff, 0x0000ff]		
LIGHT_PURPLE 	= 0xFF60FF																				
PURPLE       	= 0xFF00FF																					
							# Number of times instruction executed																													   
COLOR1 = GREEN 				# 0x0     - 0xF 							list [] of 8 colors
COLOR2 = YELLOW 			# 0x10    - 0xff 							list [] of 8 colors
COLOR3 = RED 				# 0x100   - 0xfff 							list [] of 8 colors
COLOR4 = LIGHT_PURPLE 		# 0x1000  - 0xffff 							color value
COLOR5 = PURPLE 			# 0x10000 - infinity 						color value

##############################################################################################################################
######################################## Don't edit anything below this line  ################################################
######################################## if you don't know what you are doing ################################################
##############################################################################################################################

# Setup Logging to file in %TEMP% --- Not used itm ---
# tmpdir = tempfile.gettempdir()
# ddr_logdir    = tmpdir + '\DDR'

# try:
#     os.makedirs(ddr_logdir, exist_ok=True)    # Python >3.2
# except TypeError:
#     try:
#         os.makedirs(ddr_logdir)               # Python >2.5
#     except OSError as e:
#         if e.errno == errno.EEXIST and os.path.isdir(ddr_logdir):
#             pass
#         else:
#             idaapi.warning("[DDR] Failed to make logging directory")

# ddr_logfilename = ddr_logdir + '\DDR-{:%Y-%m-%d-%H-%M-%S}.log'.format(datetime.now())
# logger = logging.getLogger("DDR")
# logger.setLevel(logging.DEBUG)
# fh = logging.FileHandler(ddr_logfilename)
# fh.setLevel(logging.DEBUG)
# formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
# fh.setFormatter(formatter)
# logger.addHandler(fh)

# Globals
# -------

# Setup menu/action items:
menu_items = OrderedDict([
("DDR_Action_Load_file"                   , { "menu_str":"Load DynRIO file"                             , "hotkey":"Ctrl+Shift+F12", "submenu":""         , "ah_id":"LoadFile"                   , "x64only":False, "hide_in_context":True }),
("DDR_Action_Trace_On_Range"              , { "menu_str":"Run full trace for marked address range"      , "hotkey":None            , "submenu":"Trace/"   , "ah_id":"Run_Trace_On_Range"         , "x64only":False, "hide_in_context":False}),
("DDR_Action_Run_Trace_On_BB"             , { "menu_str":"Run full trace for marked basic block"        , "hotkey":None            , "submenu":"Trace/"   , "ah_id":"Run_Trace_On_BB"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Run_Trace_On_Seg"            , { "menu_str":"Run full trace for Segment"                   , "hotkey":None            , "submenu":"Trace/"   , "ah_id":"Run_Trace_On_Seg"           , "x64only":False, "hide_in_context":False}),
("DDR_Action_Run_Light_Trace_On_Seg"      , { "menu_str":"Run light trace for Segment"                  , "hotkey":None            , "submenu":"Trace/"   , "ah_id":"Run_Light_Trace_On_Seg"     , "x64only":False, "hide_in_context":False}),
("DDR_Action_Delete_Cached_Files"         , { "menu_str":"Delete cached traces"                         , "hotkey":None            , "submenu":"Trace/"   , "ah_id":"Delete_Cached_Files"        , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xax"             , { "menu_str":"Get memory for ptr in xax"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xax"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xbx"             , { "menu_str":"Get memory for ptr in xbx"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xbx"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xcx"             , { "menu_str":"Get memory for ptr in xcx"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xcx"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xdx"             , { "menu_str":"Get memory for ptr in xdx"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xdx"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xsp"             , { "menu_str":"Get memory for ptr in xsp"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xsp"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xbp"             , { "menu_str":"Get memory for ptr in xbp"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xbp"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xsi"             , { "menu_str":"Get memory for ptr in xsi"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xsi"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_xdi"             , { "menu_str":"Get memory for ptr in xdi"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_xdi"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r8"              , { "menu_str":"Get memory for ptr in r8"                     , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r8"             , "x64only":True , "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r9"              , { "menu_str":"Get memory for ptr in r9"                     , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r9"             , "x64only":True , "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r10"             , { "menu_str":"Get memory for ptr in r10"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r10"            , "x64only":True , "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r11"             , { "menu_str":"Get memory for ptr in r11"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r11"            , "x64only":True , "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r12"             , { "menu_str":"Get memory for ptr in r12"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r12"            , "x64only":True , "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r13"             , { "menu_str":"Get memory for ptr in r13"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r13"            , "x64only":True , "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r14"             , { "menu_str":"Get memory for ptr in r14"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r14"            , "x64only":True , "hide_in_context":False}),
("DDR_Action_Get_Mem_Ptr_r15"             , { "menu_str":"Get memory for ptr in r15"                    , "hotkey":None            , "submenu":"Register/", "ah_id":"Get_Mem_Ptr_r15"            , "x64only":True , "hide_in_context":False}),
("DDR_Action_Set_Num_Hits_for_Cmt"        , { "menu_str":"Set number of trace hits for IDA DISASM View" , "hotkey":None            , "submenu":"Config/"  , "ah_id":"Get_Set_Num_Hits_Cmt"       , "x64only":False, "hide_in_context":False}),
("DDR_Action_Set_Num_Hits_for_IdaLog"     , { "menu_str":"Set number of trace hits for IDA log window"  , "hotkey":None            , "submenu":"Config/"  , "ah_id":"Get_Set_Num_Hits_IdaLog"    , "x64only":False, "hide_in_context":False}),
("DDR_Action_Set_Num_Max_Instr"           , { "menu_str":"Set number of instructions to log"            , "hotkey":None            , "submenu":"Config/"  , "ah_id":"Get_Set_Max_Instr"          , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetSrcOpValue"               , { "menu_str":"Get values for source operant"                , "hotkey":None            , "submenu":""         , "ah_id":"GetSrcOpValue"              , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetDstOpValue"               , { "menu_str":"Get values for destination operant"           , "hotkey":None            , "submenu":""         , "ah_id":"GetDstOpValue"              , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetSrcOpPtrValue"            , { "menu_str":"Get values for ptr in source operant"         , "hotkey":None            , "submenu":""         , "ah_id":"GetSrcOpPtrValue"           , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetDstOpPtrValue"            , { "menu_str":"Get values for ptr in destination operant"    , "hotkey":None            , "submenu":""         , "ah_id":"GetDstOpPtrValue"           , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetSrcOpPtrPtrValue"         , { "menu_str":"Get values for ptr ptr in source operant"     , "hotkey":None            , "submenu":""         , "ah_id":"GetSrcOpPtrPtrValue"        , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetDstOpPtrPtrValue"         , { "menu_str":"Get values for ptr ptr in destination operant", "hotkey":None            , "submenu":""         , "ah_id":"GetDstOpPtrPtrValue"        , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetSrcPtrMem"                , { "menu_str":"Get memory for ptr in source operant"         , "hotkey":None            , "submenu":""         , "ah_id":"GetSrcPtrMem"               , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetDstPtrMem"                , { "menu_str":"Get memory for ptr in destination operant"    , "hotkey":None            , "submenu":""         , "ah_id":"GetDstPtrMem"               , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetSrcPtrPtrMem"             , { "menu_str":"Get memory for ptr ptr in source operant"     , "hotkey":None            , "submenu":""         , "ah_id":"GetSrcPtrPtrMem"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_GetDstPtrPtrMem"             , { "menu_str":"Get memory for ptr ptr in destination operant", "hotkey":None            , "submenu":""         , "ah_id":"GetDstPtrPtrMem"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Highlight_trace"             , { "menu_str":"Highlight traced instructions"                , "hotkey":None            , "submenu":""         , "ah_id":"Highlight_trace"            , "x64only":False, "hide_in_context":False}),
("DDR_Action_Strings_View"                , { "menu_str":"Show strings trace"                           , "hotkey":None            , "submenu":""         , "ah_id":"Display_Strings_View"       , "x64only":False, "hide_in_context":False}),
("DDR_Action_Call_View"                   , { "menu_str":"Show API calls trace"                         , "hotkey":None            , "submenu":""         , "ah_id":"Display_Calls_View"         , "x64only":False, "hide_in_context":False}),
("DDR_Action_DeleteNonRepeatableComments" , { "menu_str":"Delete non-repeatable comments"               , "hotkey":None            , "submenu":""         , "ah_id":"DeleteNonRepeatableComments", "x64only":False, "hide_in_context":False})
])

SAMPLE_FILENAME = idaapi.get_root_filename()

jsondata = None
jsonfile_loaded = False
jsonfile_dir  = os.path.dirname(os.path.abspath(idaapi.get_input_file_path()))

api_calls = {}

arch_bits = None
reg_list = []

# verify directory ends with backslash
if not SERVER_LOCAL_SAMPLE_DIR.endswith("\\"):
	SERVER_LOCAL_SAMPLE_DIR += "\\"

def PLUGIN_ENTRY():
	return ddrPlugin()

def DDR_print_mesg(msg, debuglevel=0):
	"""
	Print msg to output window in IDA
	"""
	func = inspect.stack()[1][3] # Get calling function name

	if debuglevel == 0 and DBG_LEVEL >= 0:
		print("[DDR][INFO] %s" % msg)
	if debuglevel == 1 and DBG_LEVEL >= 1:
		print("[DDR][WARNING] %s" % msg)
	if debuglevel == 2 and DBG_LEVEL >= 2:
		print("[DDR][ERROR] %s" % msg)
	if debuglevel == 3 and DBG_LEVEL >= 3:                           
		print("[DDR][DEBUG_L1][%s] %s" % (func, msg))
	if debuglevel == 4 and DBG_LEVEL >= 4:
		print("[DDR][DEBUG_L2][%s] %s" % (func, msg))
	if debuglevel == 5 and DBG_LEVEL >= 5:
		print("[DDR][DEBUG_L3][%s] %s" % (func, msg))
	if debuglevel == 6 and DBG_LEVEL >= 6:
		print("[DDR][DEBUG_L4][%s] %s" % (func, msg))  
	if debuglevel == 7 and DBG_LEVEL >= 7:
		print("[DDR][DEBUG_L5][%s] %s" % (func, msg))

class DDR_ida_action_handler(idaapi.action_handler_t):
	"""
	DDR Action handler for all menu entries, gets created when user picks menu 
	"""

	def __init__(self, usrcmd):
		idaapi.action_handler_t.__init__(self)
		self.cmd = usrcmd
		DDR_print_mesg("cmd = %s" % self.cmd, 7)

	def update(self, ctx):
		"""
		Ensure the context menu is always available in IDA.
		"""
		DDR_print_mesg("[%s] updated." % self.cmd, 7)
		return idaapi.AST_ENABLE_ALWAYS

	def activate(self, ctx):
		"""
		Execute the embedded action_function when this context menu is invoked.
		"""
		DDR_print_mesg("Command selected by user: [%s]" % self.cmd, 7)
		
		global jsondata
		global jsonfile_loaded
		global MAX_LOG_ROUNDS
		global MAX_CMT_ROUNDS
		global MAX_INSTR_TO_EXECUTE

		ea = idc.ScreenEA()

		# special commands which are not ea or range related
		if self.cmd == ("Delete_Cached_Files"):
			jsonfile_name =  jsonfile_dir + "\\" + "DDR_log_" + '.'.join(idaapi.get_root_filename().split('.')[:-1]) + "*"
			for filename_to_delete in glob.glob(jsonfile_name):
				DDR_print_mesg("Deleting file(s): %s" % filename_to_delete)
				os.remove(filename_to_delete)
			return 1

		if self.cmd == ("Run_Light_Trace_On_Seg"):
			start        = idc.SegStart(ea)
			end          = idc.SegEnd(ea)
			DDR_print_mesg("Running instruction address trace only for selected segment range: %x - %x." % (start, end))
			self._exec_dynRio(start_addr=start, end_addr=end, instr_count=MAX_INSTR_TO_EXECUTE, options='light_trace_only')
			return 1

		if self.cmd == ("Run_Trace_On_Seg"):
			start        = idc.SegStart(ea)
			end          = idc.SegEnd(ea)
			DDR_print_mesg("Running trace for selected segment range: %x - %x." % (start, end))
			self._exec_dynRio(start_addr=start, end_addr=end, instr_count=MAX_INSTR_TO_EXECUTE)
			return 1

		if self.cmd == ("Run_Trace_On_Range"):
			_ , start, end = idaapi.read_selection()
			if self._selection_is_valid(start, end, ea):
				DDR_print_mesg("Running trace for selected address range: %x - %x." % (start, end))
				self._exec_dynRio(start_addr=start, end_addr=end, instr_count=MAX_INSTR_TO_EXECUTE)
			return 1

		if self.cmd == ("Run_Trace_On_BB"):
			DDR_print_mesg("Running trace for selected basic block.")
			self._exec_dynRIO_against_BB(ea)
			return 1

		if self.cmd == ("Highlight_trace"): 
			if(jsonfile_loaded == False):
				self._trace_file_not_loaded()
				return 1
			else:
				self._highlight_trace()
				return 1

		if self.cmd == ("Get_Set_Num_Hits_Cmt"):
			cmt_rnds = idc.AskLong(MAX_CMT_ROUNDS, "Please enter max. number of hits to display in IDA comments (max. %d):" % MAX_INSTR_COUNT)
			if cmt_rnds > 0 and cmt_rnds <= MAX_INSTR_COUNT:
				MAX_CMT_ROUNDS = cmt_rnds
				DDR_print_mesg("[Get_Set_Num_Hits_Cmt] Number of hits for repeatble comments %d" % MAX_CMT_ROUNDS, 7) 
			return 1

		if self.cmd == ("Get_Set_Num_Hits_IdaLog"):
			cmt_rnds = idc.AskLong(MAX_LOG_ROUNDS, "Please enter max. number of hits to display in IDA comments (max. %d):" % MAX_INSTR_COUNT)
			if cmt_rnds > 0 and cmt_rnds <= MAX_INSTR_COUNT:
				MAX_LOG_ROUNDS = cmt_rnds
				DDR_print_mesg("[Get_Set_Num_Hits_IdaLog] Number of hits for IDA log window %d" % MAX_LOG_ROUNDS, 7) 
			return 1

		if self.cmd == ("Get_Set_Max_Instr"):
			cmt_rnds = idc.AskLong(MAX_INSTR_TO_EXECUTE, "Please enter max. number of instructions to process in DynamoRio analysis (Default: 20000):")
			if cmt_rnds > 0:
				if cmt_rnds > 40000:
					idaapi.warning("Setting max. instructions to greater than 40000 might be slow. Only use it for 'Run Light Trace on Segment' feature " + 
						"or make sure you do not run into API timeouts (MAX_API_TIMEOUT) because the analysis takes too long on the server side.")
				MAX_INSTR_TO_EXECUTE = cmt_rnds
				DDR_print_mesg("[Get_Set_Max_Instr] Max. Number of instructions to process in DynamoRio analysis set to: %d" % MAX_INSTR_TO_EXECUTE, 7)
			return 1

		if self.cmd == ("Display_Strings_View"):
			if(jsonfile_loaded == False):
				self._trace_file_not_loaded()
				return 1	
			else:
				items = self._get_chooser_row_list_strings()
				DDR_print_mesg("Len items: %d" % len(items),7)
				columns = [ ["Instruction #", 6], ["Address", 12], ["Type", 15], ["Data Hex", 25], ["Data Address", 12], ["String", 12], ["Disasm", 35] ]
				c = DDR_MyChoose2("Strings Trace", items=items, modal=False, columns=columns)
				if not c.show():
					DDR_print_mesg("Failed to start Strings Trace View", 7)
				else:
					DDR_print_mesg("Strings Trace View created", 7)
				return 1 

		if self.cmd == ("Display_Calls_View"):
			if(jsonfile_loaded == False):
				self._trace_file_not_loaded()
				return 1
			else:
				items = self._get_chooser_row_list_calls()
				DDR_print_mesg("Len items: %d" % len(items),7)
				columns = [ ["Instruction #", 6], ["Address", 12], ["Type", 15], ["Data Address", 12], ["API call", 12], ["API module", 12], ["Disasm", 35] ]
				c = DDR_MyChoose2("API Call Trace", items=items, modal=False, columns=columns)
				if not c.show():
					DDR_print_mesg("Failed to start Call Trace View", 7)
				else:
					DDR_print_mesg("Call Trace View created", 7)
				return 1 

		# Load DynamoRIO JSON File 
		if self.cmd == "LoadFile" :
			self._load_JSON_file()
			return 1

		# Delete comments
		if self.cmd == "DeleteNonRepeatableComments":
			try:
				_ , start, end = idaapi.read_selection()
				# User selected multiple lines
				if self._selection_is_valid(start, end, ea):
					DDR_print_mesg("[%s] selected processing range: %x - %x" % (self.cmd, start, end),7)
					ea=start
					while(ea <= end):
						DDR_print_mesg("[Range] Delete non-repeatable comments.... %x" % ea, 7)   
						idc.MakeComm(ea, "")         
						ea = idc.NextHead(ea)
				# User selected single line
				else:
					DDR_print_mesg("[%s] selected address: %x" % (self.cmd, ea),7)  
					DDR_print_mesg("[SingleAddress] Delete non-repeatable comments.... %x" % ea, 7)
					idc.MakeComm(ea, "")
				return 1
			except:
				raise


		# Parse all the other menu items (parse_ea) which can be applied to a single ea or a range 
		if(jsonfile_loaded == True):
			_ , start, end = idaapi.read_selection()
			# User selected multiple lines
			if self._selection_is_valid(start, end, ea):
				DDR_print_mesg("[%s] selected processing range: %x - %x" % (self.cmd, start, end),7)
				ea=start
				while(ea <= end):
					self._parse_ea(ea)
					ea = idc.NextHead(ea)
			# User selected single line
			else:
				DDR_print_mesg("[%s] selected address: %x" % (self.cmd, ea),7)
				self._parse_ea(ea)
		else:
			self._trace_file_not_loaded()
			
		return 1

	def _parse_ea(self, ea):
		"""
		Main parser method for parsing and analysing data at address (ea)
		"""
		
		op0 = idc.GetOpnd(ea,0)
		op1 = idc.GetOpnd(ea,1)
		op0_type = idc.GetOpType(ea,0)
		op1_type = idc.GetOpType(ea,1)

		DDR_print_mesg("Address: 0x%x:" % ea)
		DDR_print_mesg("  DISASM   : %s" % idc.GetDisasm(ea))
		DDR_print_mesg("  CMD      : %s" % self.cmd, 7)
		DDR_print_mesg("  OP0      : %s" % op0,7)
		DDR_print_mesg("  OP1      : %s" % op1,7)
		DDR_print_mesg("  OP0 type : %x" % op0_type,7)
		DDR_print_mesg("  OP1 type : %x" % op1_type,7)
		DDR_print_mesg("  OP0 value: %x" % idc.GetOperandValue(ea,0),7)
		DDR_print_mesg("  OP1 value: %x" % idc.GetOperandValue(ea,1),7)

		# Handle selected menu entries
		if self.cmd == "GetSrcOpValue":
			trace_instr_num_list = self._get_trace_instr_list(ea) 
			self._set_ida_src_op_name(ea)
			self._handle_trace_list(ea, self.src_op, "inst_mem_addr_src0", trace_instr_num_list, "SrcVal")

		if self.cmd == "GetDstOpValue":
			trace_instr_num_list = self._get_trace_instr_list(ea) 
			self._set_ida_dst_op_name(ea)
			self._handle_trace_list(ea, self.dst_op, "inst_mem_addr_dst0", trace_instr_num_list, "DstVal")
		  
		if self.cmd == "GetSrcOpPtrValue":
			DDR_print_mesg("Menu GetSrcOpPtrValue selected")
			trace_instr_num_list = self._get_trace_instr_list(ea) 
			self._set_ida_src_op_name(ea)
			self._handle_trace_list_ptr_value(ea, self.src_op, "inst_mem_addr_src0_data", trace_instr_num_list, "SrcValPtr")

		if self.cmd == "GetDstOpPtrValue":
			DDR_print_mesg("Menu GetDstOpPtrValue selected")
			trace_instr_num_list = self._get_trace_instr_list(ea) 
			self._set_ida_dst_op_name(ea)
			self._handle_trace_list_ptr_value(ea, self.dst_op, "inst_mem_addr_dst0_data", trace_instr_num_list, "DstValPtr")

		if self.cmd == "GetSrcOpPtrPtrValue":
			DDR_print_mesg("Menu GetSrcOpPtrPtrValue selected")
			trace_instr_num_list = self._get_trace_instr_list(ea) 
			self._set_ida_src_op_name(ea)
			self._handle_trace_list_ptr_value(ea, self.src_op, "inst_mem_addr_src0_data_ptr_data", trace_instr_num_list, "SrcValPtrPtr")

		if self.cmd == "GetDstOpPtrPtrValue":
			DDR_print_mesg("Menu GetDstOpPtrPtrValue selected")
			trace_instr_num_list = self._get_trace_instr_list(ea) 
			self._set_ida_dst_op_name(ea)
			self._handle_trace_list_ptr_value(ea, self.dst_op, "inst_mem_addr_src0_data_ptr_data", trace_instr_num_list, "DstValPtrPtr")

		if self.cmd=="GetSrcPtrMem":
			trace_instr_num_list = self._get_trace_instr_list(ea)
			self._set_ida_src_op_name(ea)
			self._handle_trace_list_ptr(ea, self.src_op, "inst_mem_addr_src0_data", trace_instr_num_list, "SrcPtrMem")  

		if self.cmd=="GetDstPtrMem":
			trace_instr_num_list = self._get_trace_instr_list(ea)
			self._set_ida_dst_op_name(ea)
			self._handle_trace_list_ptr(ea, self.dst_op, "inst_mem_addr_dst0_data", trace_instr_num_list, "DstPtrMem")  

		if self.cmd=="GetSrcPtrPtrMem":
			trace_instr_num_list = self._get_trace_instr_list(ea)
			self._set_ida_src_op_name(ea)
			self._handle_trace_list_ptr(ea, self.src_op, "inst_mem_addr_src0_data_ptr_data", trace_instr_num_list, "SrcPtrPtrMem")

		if self.cmd=="GetDstPtrPtrMem":
			trace_instr_num_list = self._get_trace_instr_list(ea)
			self._set_ida_dst_op_name(ea)
			self._handle_trace_list_ptr(ea, self.dst_op, "inst_mem_addr_dst0_data_ptr_data", trace_instr_num_list, "DstPtrPtrMem")

		# --- Register menu selected ---
		# reg_list(64) = ["xax","xbx","xcx","xdx","xsp","xbp","xsi","xdi","r8","r9","r10","r11","r12","r13","r14","r15"]
		# reg_list(32) = ["xax","xbx","xcx","xdx","xsp","xbp","xsi","xdi"]
		for reg in reg_list:
			DDR_print_mesg("reg:%s" % reg , 7) 
			if self.cmd=="Get_Mem_Ptr_" + reg:
				trace_instr_num_list = self._get_trace_instr_list(ea)
				self._set_ida_comment_regmenu_mem_ptr(ea, reg, trace_instr_num_list)

		DDR_print_mesg("-------------------------------------------------------------------------------")
		return True

	def _trace_file_not_loaded(self):
		DDR_print_mesg("Trace file not loaded. Pls use 'Trace' menu to run a trace first.", 1)
		DDR_print_mesg("Alternativly, you can use 'File/Load File/Load DynRIO file' to load a custom trace file.", 1)
		idaapi.warning("Trace file not loaded. Pls use 'Trace' menu to run a trace first or load a custom trace file via 'File/Load File/Load DynRIO file'.") 

	def _load_APICalls_file(self, filename = None):
		global api_calls
		api_calls = {}      # reset API calls dict

		# TBD try/except block
		with open(filename) as apicall_file: 
			apicall_data = json.load(apicall_file)
			apicall_loaded = True
		DDR_print_mesg("API calls file loaded: %s" % filename) 

		# Build call dict with address as key
		for call in apicall_data["apicalls"]:
			if call["address"] in api_calls:
				old_name = api_calls[call["address"]]
				api_calls[call["address"]] = call["name"] + "," + old_name  
			else:
				api_calls[call["address"]] = call["name"] + ";" + call["module"]

		return True


	def _load_JSON_file(self, filename = None):
		""" Loads DynamoRIO generated JSON file """
		global jsondata
		global jsonfile_loaded

		if filename == None:
			filename = self._get_JSON_file()

		try:
			with open(filename) as json_file:  
				jsondata = json.load(json_file)
				jsonfile_loaded = True
				DDR_print_mesg("JSON file was generated for executable: %s" % (jsondata["samplename"]))
				if arch_bits == 64 and jsondata["architecture"] != "x64":
					idaapi.warning("JSON File has wrong architecture: %s" % jsondata["architecture"])
					DDR_print_mesg("JSON File has wrong architecture: %s" % jsondata["architecture"])
					jsonfile_loaded = False
					return False
				elif arch_bits == 32 and jsondata["architecture"] != "x32":
					idaapi.warning("JSON File has wrong architecture: %s" % jsondata["architecture"])
					DDR_print_mesg("JSON File has wrong architecture: %s" % jsondata["architecture"])
					jsonfile_loaded = False
					return False
				else:
					DDR_print_mesg("Instructions traced in JSON file: %d" % len(jsondata["instruction"]))
					return True
		except IOError as e:
			DDR_print_mesg("Failed to open JSON file. Quitting operation.")
			jsonfile_loaded = False
			return False
		except ValueError as e:
			DDR_print_mesg("[ERROR] Failed to parse JSON file: %s. Quitting operation." % filename)
			DDR_print_mesg("[ERROR] Please check file format is JSON and try again.")
			e_args = ''.join(map(str,e.args))
			DDR_print_mesg("%s" % e_args)
			jsonfile_loaded = False
			idaapi.warning("[DDR] Failed to open JSON file. Check Logging window for details.")
			return False
		else:
			DDR_print_mesg("[ERROR] Failed to open JSON file: %s with unknown error. Quitting operation." % filename)
			jsonfile_loaded = False
			idaapi.warning("[DDR] Failed to open JSON file. Check Logging window for details.")
			raise


	def _get_JSON_file(self):
		"""
		Prompt a file selection dialog, returning file selections.
		"""
		my_dir = jsonfile_dir

		# create & configure a Qt File Dialog for immediate use
		file_dialog = QtWidgets.QFileDialog(
			None,
			'Open DDR DynamoRIO generated JSON file',
			#idautils.GetIdbDir(),
			my_dir,
			'All Files (*.*)'
		)
		file_dialog.setFileMode(QtWidgets.QFileDialog.ExistingFiles)

		# prompt the user with the file dialog, and await filename(s)
		filename, _ = file_dialog.getOpenFileName()

		# log the selected filenames from the dialog
		DDR_print_mesg("DynRIO JSON input file loaded: %s" % filename)

		# return the captured filenames
		return filename


	def _highlight_trace(self):
		""" Highlight basics blocks in IDA graph disasm view"""
		
		#idaapi.get_item_color(ea)   # Get actual color at ea

		# green  		= [0xa0ffa0, 0x70ff70, 0x00ff00, 0x00ef00, 0x00df00, 0x00cf00, 0x00bf00, 0x00af00]  # 0x0   - 0xf
		# yellow 		= [0xd0ffff, 0xa0ffff, 0x70ffff, 0x00ffff, 0x00efff, 0x00dfff, 0x00cfff, 0x00bfff]	# 0x10  - 0xff
		# red    		= [0xC0C0ff, 0xB0B0ff, 0xA0A0ff, 0x8080ff, 0x6060ff, 0x4040ff, 0x2020ff, 0x0000ff]	# 0x100 -  0xfff
		# light_purple 	= 0xFF60FF																			# 0x1000  - 0xffff
		# purple       	= 0xFF00FF																			# 0x10000 - infinity

		inst_addr_list = []
		for instr in jsondata["instruction"]:
			inst_addr_list.append(int(instr["address"], 16))

		DDR_print_mesg("Generated instruction list to highlight graph basic blocks. Number of Instructions processed: %d" % len(inst_addr_list))
		DDR_print_mesg("-------------------------------------------------------------------------------")

		inst_addr_counter = Counter(inst_addr_list)

		# paint lines depending on the number of occurences in the trace 
		# Default: (green 0-0xf, yellow 0x10 - 0xff, red 0x100 - 0xfff, light_purple 0x1000 - 0xffff, purple > 0xffff)
		for ea in inst_addr_counter:
			if inst_addr_counter[ea] > 0xffff:  
				idaapi.set_item_color(ea, COLOR5)
				continue

			if inst_addr_counter[ea] > 0xfff:  
				idaapi.set_item_color(ea, COLOR4)
				continue

			if inst_addr_counter[ea] > 0xff: 
				if inst_addr_counter[ea] <= 7:
					color = COLOR3[inst_addr_counter[ea]]
				else:
					color = COLOR3[7]
				idaapi.set_item_color(ea, color)
				continue

			if inst_addr_counter[ea] > 0xf: 
				if inst_addr_counter[ea] <= 7:
					color = COLOR2[inst_addr_counter[ea]]
				else:
					color = COLOR2[7]
				idaapi.set_item_color(ea, color)
				continue

			if inst_addr_counter[ea] <= 0xf:
				if inst_addr_counter[ea] <= 7:
					color = COLOR1[inst_addr_counter[ea]]
				else:
					color = COLOR1[7]
				idaapi.set_item_color(ea, color)
					   
	def _selection_is_valid(self, start, end, ea):
		"""If the cursor is not at the beginning or the end of our selection, assume that something has gone wrong """
		if not (ea == start or ea == end):
			return False
		else:
			return True

	def _find_apicall_for_addr(self, addr):
		""" Check if addr is a symbol / known api address"""
		if addr in api_calls:
			apiname_with_module = api_calls[addr]
			name = apiname_with_module.split(";")[0]
			module = apiname_with_module.split(";")[1]
			return name, module
		return "-", "-"

	def _get_chooser_row_list_strings(self) :
		""" Fill the lines list used for the Trace Window item list"""

		lines = []
		for instr in jsondata["instruction"]:                               
			for s in [ "inst_mem_addr_src0_data", "inst_mem_addr_src0_data_ptr_data"]:
				try:
					line  = []
					line.append("%12d" % int(instr["instr_num"],10))            # instruction number in trace
					line.append(str(instr["address"]))                          # ea address of instruction
					if s == "inst_mem_addr_src0_data":
						datatype = "Pointer"                                    
					else:
						datatype = "Pointer-Pointer"                            
					line.append(datatype)                                       # JSON field (type) of string
					mystring = str(instr[s])
					stringlist = mystring.split("    ")
					line.append(stringlist[0])                                  # String in Hex
					data_addr = self._get_addr_from_data(mystring)
					line.append(data_addr)                                      # Data address extracted from mystring
					line.append("".join(stringlist[1:]))                        # String
					line.append(str(instr["disasm"]))                           # Disasm of instruction
					lines.append(line)                                          # add generated line to lines list
				except KeyError as e:
					break                                                       # key doesn't exists in JSON file, try next instruction

		return lines

	def _get_chooser_row_list_calls(self) :
		""" Fill the lines list used for the API calls Window item list"""
		lines = []
		for instr in jsondata["instruction"]:    
			disasm = str(instr["disasm"])                          
			
			try:
				val = instr["inst_mem_addr_src0"]
			except:
				val = "0x0"

			try:
				ptr = instr["inst_mem_addr_src0_data_ptr"]
			except:
				ptr = "0x0"

			apicall_val, apimodule_val = self._find_apicall_for_addr(val)
			apicall_ptr, apimodule_ptr = self._find_apicall_for_addr(ptr) 

			if apicall_val == '-' and apicall_ptr == '-':
				continue

			if apicall_val != '-':
				datatype  = "Value"
				data_addr = val
				apicall   = apicall_val
				apimodule = apimodule_val
			else:
				datatype  = "Pointer"
				data_addr = ptr
				apicall   = apicall_ptr
				apimodule = apimodule_ptr

			line  = []
			line.append("%12d" % int(instr["instr_num"],10))            # instruction number in trace
			line.append(str(instr["address"]))                          # ea address of instruction
			line.append(datatype)                                       # JSON field (type) of string
			line.append(data_addr)                                      # address called
			line.append(apicall)                                        # API call name
			line.append(apimodule)                                      # API module name
			line.append(disasm)                                         # Disasm of instruction
			lines.append(line)                                          # add generated line to lines list

		return lines

	def _set_ida_src_op_name(self, ea):
		""" Find source operant of instruction and set src_op name"""
		op0 = idc.GetOpnd(ea,0)
		op1 = idc.GetOpnd(ea,1)
		op0_type = idc.GetOpType(ea,0)
		op1_type = idc.GetOpType(ea,1)

		if op1_type == idaapi.o_void:
			self.src_op = op0
		else:
			self.src_op = op1

		if op0_type == idaapi.o_void:
			self.src_op = "src_op not set"

	def _set_ida_dst_op_name(self, ea):
		""" Find destination operant of instruction and set dst_op name"""
		op0 = idc.GetOpnd(ea,0)
		op1_type = idc.GetOpType(ea,1)

		if op1_type == idaapi.o_void:
			self.dst_op = "dst_op not set"
		else:
			self.dst_op = op0

	def _handle_trace_list_ptr_value(self, ea, op, json_instr_field, trace_instr_num_list, usrcmd):
		comment = ""
		if not trace_instr_num_list:
			comment = "Instruction at %x not in trace" % ea

		#TBD: sub optimal algorithm, fix this
		for c,i in enumerate(trace_instr_num_list):
			try:
				if c < MAX_LOG_ROUNDS:
					data = jsondata["instruction"][i][json_instr_field]
					addr = self._get_addr_from_data(data)
					apicall, apimodule = self._find_apicall_for_addr(addr)
					DDR_print_mesg("    %s:%s  APIname:%s  Module:%s" % (usrcmd,addr,apicall,apimodule))
				if c < MAX_CMT_ROUNDS:
					data = jsondata["instruction"][i][json_instr_field]
					addr = self._get_addr_from_data(data)
					apicall, apimodule = self._find_apicall_for_addr(addr)
					if apicall == '-':
						comment += "%s:0x%x; " % (usrcmd, int(addr,16))  # delete leading zeros
					else:
						comment += "%s:%s; " % (usrcmd, apicall)  
			except:
				if c < MAX_LOG_ROUNDS:
					DDR_print_mesg("    %s:InstrAddr=0x%x instr number:%07d = No pointer found" % (usrcmd, ea, i))
				if c < MAX_CMT_ROUNDS:
					comment += "%s:PtrNotFound; " % usrcmd 


		# Get existing commend and add our dynamic data to it.
		org_cmt = idc.GetCommentEx(ea, False)
		if org_cmt != None:
			new_comment = org_cmt + "\n" + comment
		else:
			new_comment = comment

		idc.MakeComm(ea, str(new_comment))   # IDA doesn't like unicode from JSON file 


	def _handle_trace_list(self, ea, op, json_instr_field, trace_instr_num_list, usrcmd):
		""" Get content from 'json_instr_field' key from JSON file and generate corrosponding comment for value"""
		comment = ""
		if not trace_instr_num_list:
			comment = "Instruction at 0x%x not in trace" % ea

		for c,i in enumerate(trace_instr_num_list):
			try:
				addr = jsondata["instruction"][i][json_instr_field]
				if c < MAX_LOG_ROUNDS:
					apicall, apimodule = self._find_apicall_for_addr(addr)
					DDR_print_mesg("    %s(%s)@0x%x@instr number:%07d = 0x%x (APIname:%s  Module:%s)" % 
						(usrcmd, op, ea, i, int(addr,16), apicall,apimodule))

				if c < MAX_CMT_ROUNDS:
					apicall, apimodule = self._find_apicall_for_addr(addr)
					if apicall == '-':
						comment += "%s:0x%x; " % (usrcmd, int(addr,16))  # delete leading zeros
					else:
						comment += "%s:%s; " % (usrcmd, apicall)  
			except:
				if c < MAX_LOG_ROUNDS:
					DDR_print_mesg("    %s(%s)@0x%x@instr number:%07d = No memory data found in JSON file" % (usrcmd, op, ea, i))
				if c < MAX_CMT_ROUNDS:
					comment += "%s(%s):NotFound; " % (usrcmd,op) 

		# Get existing commend and add our dynamic data to it.
		org_cmt = idc.GetCommentEx(ea, False)
		if org_cmt != None:
			new_comment = org_cmt + "\n" + comment
		else:
			new_comment = comment

		idc.MakeComm(ea, str(new_comment))    

	def _handle_trace_list_ptr(self, ea, op, json_instr_field, trace_instr_num_list, usrcmd):
		""" Get content from 'json_instr_field' key from JSON file and generate corrosponding comment for pointer or pointer-pointer"""
		comment = ""
		if not trace_instr_num_list:
			comment = "Instruction at 0x%x not in trace" % ea

		for c,i in enumerate(trace_instr_num_list):
			try:
				if c < MAX_LOG_ROUNDS:
					DDR_print_mesg("    %s(%s)@0x%x@instr number:%07d = %s" % (usrcmd, op, ea, i, str(jsondata["instruction"][i][json_instr_field])))
				if c < MAX_CMT_ROUNDS:
					comment += "%s(%s):%s; " % (usrcmd, op, str(jsondata["instruction"][i][json_instr_field])) 
			except:
				if c < MAX_LOG_ROUNDS:
					DDR_print_mesg("    %s(%s)@0x%x@instr number:%07d = No memory data found in JSON file" % (usrcmd, op, ea, i))
				if c < MAX_CMT_ROUNDS:
					comment += "%s(%s):NotFound; " % (usrcmd,op) 

		# Get existing commend and add our dynamic data to it.
		org_cmt = idc.GetCommentEx(ea, False)
		if org_cmt != None:
			new_comment = org_cmt + "\n" + comment
		else:
			new_comment = comment

		idc.MakeComm(ea, new_comment)        
 
	def _set_ida_comment_regmenu_mem_ptr(self, ea, reg, trace_instr_num_list):
		""" Prints out the content stored in the register and the memory data the register value is pointing to, then adds a comment to the disasm view"""
		comment = ""

		if not trace_instr_num_list:
			comment = "Instruction at 0x%x not in trace" % ea

		for c,i in enumerate(trace_instr_num_list):
			if c < MAX_LOG_ROUNDS:
				DDR_print_mesg("    %s(=%s)@instr number:%07d = %s" % (reg, jsondata["instruction"][i][reg], i, jsondata["instruction"][i][reg + "_ptr_data"]))
			if c < MAX_CMT_ROUNDS:
				s_pdata  = str(jsondata["instruction"][i][reg + "_ptr_data"])
				regval   = int(jsondata["instruction"][i][reg],16)

				if not s_pdata == "NO_DATA":
					s_cmt   = str("%s(0x%x)=%s; " % (reg, regval, s_pdata)) #IDA doesn't like unicode type
				else:
					s_cmt   = str("%s(0x%x); " % (reg, regval))

				comment += s_cmt

		# Get existing commend and add our dynamic data to it.
		org_cmt = idc.GetCommentEx(ea, False)
		if org_cmt != None:
			new_comment = org_cmt + "\n" + comment
		else:
			new_comment = comment

		idc.MakeComm(ea, new_comment)

	def _get_addr_from_data(self, data):
		""" Extracts an address from the data bytes stream e.g. 04 03 02 01 00 00 00 ... => 01020304. Returns the addrs as string with a leading 0x... """
		if arch_bits == 64:
			s_addr = data[21:23] + data[18:20] + data[15:17] + data[12:14] + data[9:11] + data[6:8] + data[3:5] + data[:2] 
		else:
			s_addr = data[9:11] + data[6:8] + data[3:5] + data[:2] 

		return "0x" + s_addr

	def _get_trace_instr_list(self, ea):
		""" Get instruction number list from JSON trace file for ea address, if operant is a memory address"""

		trace_instr_num_list = []
		trace_instr_num_list = self._find_instr_addr_in_json(ea, trace_instr_num_list)

		DDR_print_mesg("Build list for ea=0x%x length_trace_instr_num_list=%d" % (ea, len(trace_instr_num_list)),7)

		if not trace_instr_num_list:
			DDR_print_mesg("Instruction address 0x%x not found in trace file." % ea)

		return trace_instr_num_list

	def _find_instr_addr_in_json(self, ea, trace_instr_num_list):
		""" Return a list of all instructions from the JSON file which match the ea address"""
		i=0
		c=0
		for instr in jsondata["instruction"]:                               # TBD change to eval..
			jsonaddr = int(jsondata["instruction"][i]["address"], 16)
			#DDR_print_mesg("jsonaddr=0x%x  ea=0x%x\n" %(jsonaddr,ea))
			if jsonaddr == ea:
				DDR_print_mesg("    %d. Found instr address    : %x" % (i, ea),7)
				trace_instr_num_list.append(i)
				c += 1
				if c > MAX_INSTR_COUNT-1: break
			i += 1

		DDR_print_mesg("    Number of times instruction at address (0x%x) executed in trace file: %d" % (ea, len(trace_instr_num_list)))

		return trace_instr_num_list

	def _exec_dynRIO_against_BB(self, ea):
		""" runs DynamoRio analysis against the marked basic block (only works for functions)"""
		f = idaapi.get_func(ea)

		if not f:
			DDR_print_mesg("No function found at 0x%x. This only works inside of functions." % (ea))
			idaapi.warning("No function found at 0x%x. This only works inside of functions." % (ea))
			return

		fc = idaapi.FlowChart(f)
		for block in fc:
			if block.startEA <= ea:
				if block.endEA > ea:
					DDR_print_mesg("0x%x is part of block [0x%x - 0x%x)" % (ea, block.startEA, idc.PrevHead(block.endEA)),7)
					self._exec_dynRio(start_addr=block.startEA, end_addr=idc.PrevHead(block.endEA), instr_count=MAX_INSTR_TO_EXECUTE)

	def _exec_dynRio(self, start_addr=None, end_addr=None, break_addr=None, instr_count=None, options=None):
		""" Wrapper to prepare calling the DDRsever.py API _call_api method"""
		if start_addr == None or end_addr == None or instr_count == None:
			DDR_print_mesg("start_addr, end_addr or instr_count not set")
			return False

		DDR_print_mesg("Block 0x%x - 0x%x" % (start_addr, end_addr),7)

		dynrio_sample = SERVER_LOCAL_SAMPLE_DIR + SAMPLE_FILENAME

		if options == "light_trace_only":
			cmd_id = 3
		else:
			cmd_id = 1

		self._call_api(cmd_id       = cmd_id,               # run dynamoRIO client against sample 
					  dynrio_sample = dynrio_sample,        # sample file to analyse
					  start_addr    = start_addr,           # start address to log
					  end_addr      = end_addr,             # end address to log
					  instr_count   = MAX_INSTR_TO_EXECUTE, # max number of instructions to execute in the trace
					  arch_bits     = arch_bits,            # 32 or 64 bit sample architecture
					  options       = options)              # option e.g. light_trace_only        
		
		return True

	def _call_api(self, cmd_id=0, dynrio_sample=None, start_addr=None, end_addr=None, instr_count=None, arch_bits=None, options=None ):
		""" Main method to call the DDRserver.py API"""

		# build json file name
		jsonfile_name     =  jsonfile_dir + "\\" + "DDR_log_" + '.'.join(idaapi.get_root_filename().split('.')[:-1])
		jsonfile_name     += "_0x%x" % start_addr + "-" + "0x%x" % end_addr + "_%d" % instr_count 
		jsonfile_api      =  jsonfile_name + "_apicalls.json"
		zipfilename       =  jsonfile_name + ".zip"

		url = "https://" + WEBSERVER + ":" + WEBSERVER_PORT + "/api/v1/cmd" 

		try:
			# Full trace of sample file
			if cmd_id == 1: 
				DDR_print_mesg("Calling API id 1 = Analyse file")
				jsonfile_name += ".json"
				# Did we already analysed the address range ?
				DDR_print_mesg("Looking for file: %s" % jsonfile_name)
				if os.path.exists(jsonfile_name) and os.path.exists(jsonfile_api):
					DDR_print_mesg("Instruction and API call file already exist.") 
					DDR_print_mesg("Loading: %s" % jsonfile_name)
					self._load_JSON_file(filename=jsonfile_name)
					DDR_print_mesg("Loading: %s" % jsonfile_api)
					self._load_APICalls_file(filename=jsonfile_api)

				# ...if not, start analysis:
				else:
					# download samplefile
					postpara = { 'id'            : cmd_id ,                 # run dynamoRIO client against sample
								 'apikey'        : DDR_WEBAPI_KEY,          # API key
								 'end_addr'      : end_addr,                # start address
								 'start_addr'    : start_addr,              # end address
								 'dynrio_sample' : dynrio_sample,           # sample to analyse
								 'instr_count'   : instr_count,             # max. number of instructions to trace
								 'arch_bits'     : arch_bits }              # sample architecture 32 or 64 bit
			   
					DDR_print_mesg("Asking DDR Server to run DynamoRio analysis for address range 0x%x - 0x%x. Max. instructions: %d Please be patient..." % (start_addr, end_addr, instr_count))
					
					if VERIFY_CERT:
						res = requests.post(url, verify=CA_CERT, data = postpara, timeout=MAX_API_TIMEOUT, stream=True)
					else:
						res = requests.post(url, verify=False, data = postpara, timeout=MAX_API_TIMEOUT, stream=True)

					with open(zipfilename, 'wb') as f:
						for chunk in res.iter_content(chunk_size=1024): 
							if chunk: 
								f.write(chunk)
					if res.status_code == 200:
						DDR_print_mesg("Analysis done. Downloaded zip file from server: %s" % zipfilename)
						# Extract files from zip archive
						with zipfile.ZipFile(zipfilename, "r") as ziparchive:
							DDR_print_mesg("Extracting files to %s" % jsonfile_dir)
							ziparchive.extractall(jsonfile_dir)
						# Delete zip archive
						DDR_print_mesg("Delete archive: %s" % zipfilename)
						os.remove(zipfilename)

						# Delete temp. file on server if we successfully downloaded and parsed the file
						if self._load_JSON_file(filename=jsonfile_name):
							DDR_print_mesg("JSON file succesfully parsed: %s" % jsonfile_name)
							if self._load_APICalls_file(filename=jsonfile_api):
								postpara['id'] = 2  # Delete file
								
								if VERIFY_CERT:
									res = requests.post(url, verify=CA_CERT, data = postpara, timeout=MAX_API_TIMEOUT, stream=True)
								else:
									res = requests.post(url, verify=False, data = postpara, timeout=MAX_API_TIMEOUT, stream=True)

								DDR_print_mesg("Told server to delete local temp. file. Respondscode=%d API status:%s" 
									% (res.status_code, res.json()["return_status"]))
								DDR_print_mesg("-------------------------------------------------------------------------------")
					else:
						res.raise_for_status()

			# Light instruction trace only
			if cmd_id == 3: 
				DDR_print_mesg("Calling API id 3 = Run instruction trace only")
				jsonfile_name_light_trace_only = jsonfile_name + "_trace-only.json"
				DDR_print_mesg("Looking for file: %s" % jsonfile_name_light_trace_only)
				if os.path.exists(jsonfile_name_light_trace_only):
					DDR_print_mesg("Light trace file already exist.") 
					DDR_print_mesg("Loading: %s" % jsonfile_name_light_trace_only)
					self._load_JSON_file(filename=jsonfile_name_light_trace_only)
					DDR_print_mesg("Loading: %s" % jsonfile_api)
					self._load_APICalls_file(filename=jsonfile_api)
				else:
					# download samplefile
					postpara = { 'id'            : cmd_id ,                 # run dynamoRIO client against sample
								 'apikey'        : DDR_WEBAPI_KEY,          # API key
								 'end_addr'      : end_addr,                # start address
								 'start_addr'    : start_addr,              # end address
								 'dynrio_sample' : dynrio_sample,           # sample to analyse
								 'instr_count'   : instr_count,             # max. number of instructions to trace
								 'arch_bits'     : arch_bits,               # sample architecture 32 or 64 bit
								 'opt'           : options }                # further options e.g. light_trace_only
			   
					DDR_print_mesg("Asking DDR Server to run DynamoRio instruction trace for address range 0x%x - 0x%x. Max. instructions: %d Please be patient..." % (start_addr, end_addr, instr_count))
					
					if VERIFY_CERT:
						res = requests.post(url, verify=CA_CERT, data = postpara, timeout=MAX_API_TIMEOUT, stream=True)
					else:
						res = requests.post(url, verify=False, data = postpara, timeout=MAX_API_TIMEOUT, stream=True) 

					with open(zipfilename, 'wb') as f:
						for chunk in res.iter_content(chunk_size=1024): 
							if chunk: 
								f.write(chunk)
					if res.status_code == 200:
						DDR_print_mesg("Analysis done. Downloaded zip file from server: %s" % zipfilename)
						# Extract files from zip archive
						with zipfile.ZipFile(zipfilename, "r") as ziparchive:
							DDR_print_mesg("Extracting files to %s" % jsonfile_dir)
							ziparchive.extractall(jsonfile_dir)
						# Delete zip archive
						DDR_print_mesg("Delete archive: %s" % zipfilename)
						os.remove(zipfilename)

						# Delete temp. file on server if we successfully downloaded and parsed the file
						if self._load_JSON_file(filename=jsonfile_name_light_trace_only):
							DDR_print_mesg("JSON file succesfully parsed: %s" % jsonfile_name_light_trace_only)
							if self._load_APICalls_file(filename=jsonfile_api):
								postpara['id'] = 4  # Delete file
								
								if VERIFY_CERT:
									res = requests.post(url, verify=CA_CERT, data = postpara, timeout=MAX_API_TIMEOUT, stream=True)
								else:
									res = requests.post(url, verify=False, data = postpara, timeout=MAX_API_TIMEOUT, stream=True)

								DDR_print_mesg("Told server to delete local temp. file. Respondscode=%d API status:%s" 
									% (res.status_code, res.json()["return_status"]))
								DDR_print_mesg("-------------------------------------------------------------------------------")
					else:
						res.raise_for_status()

		except requests.exceptions.SSLError as e:
			DDR_print_mesg("[SSL ERROR]: %s" % e)

		except requests.exceptions.ConnectionError as e:
			DDR_print_mesg("[CONNECTION ERROR]: %s" % e)
			DDR_print_mesg("\nDid you start and configure the DDR server script or is there any firewall inbetween ?")

		except requests.exceptions.HTTPError as e:
			DDR_print_mesg("[HTTP ERROR]: %s" % e)
			DDR_print_mesg("\nCMD execution failed. Check server side for details")

		except requests.exceptions.ReadTimeout as e:
			DDR_print_mesg("[TIMEOUT ERROR]: %s" % e)

		except ValueError as e:
			DDR_print_mesg("JSON ERROR: Failed to decode the returned data: %s\n" % e)

		except:
			DDR_print_mesg("[ERROR] Unkown error happend. REST API request failed.")
			raise


class ddrPlugin(idaapi.plugin_t):
	"""
	The IDA plugin stub for DDR.
	"""

	DDR_print_mesg("Start initalizing plugin...")

	#
	# Plugin flags:
	# - PLUGIN_MOD: DDR may modify the database
	# - PLUGIN_PROC: Load/unload DDR when an IDB opens / closes
	# - PLUGIN_HIDE: Hide DDR from the IDA plugin menu
	#
	flags = idaapi.PLUGIN_PROC | idaapi.PLUGIN_MOD 
	comment = "Dynamic Data Resolver Plugin"
	help = ""
	wanted_name = "DDR"
	wanted_hotkey = ""

	def activate(self,ctx):
		return 1

	def init(self):
		"""
		This is called by IDA when it is loading the plugin.
		"""

		global arch_bits
		global reg_list

		info = idaapi.get_inf_structure()

		if info.is_64bit():
			arch_bits = 64
			DDR_print_mesg("We are in a 64bit world...",7)
			reg_list = ["xax","xbx","xcx","xdx","xsp","xbp","xsi","xdi","r8","r9","r10","r11","r12","r13","r14","r15"]
		elif info.is_32bit():
			arch_bits = 32
			DDR_print_mesg("We are in a 32bit world...",7)
			reg_list = ["xax","xbx","xcx","xdx","xsp","xbp","xsi","xdi"]
		else:
			arch_bits = 16
			DDR_print_mesg("[ERROR] We are in a 64bit world, this plugin only supports 64/32bit enviroments. Unloading plugin.",7)
			return idaapi.PLUGIN_SKIP
		
		# Register Menu Actions
		for m in menu_items:
			if arch_bits != 64:
				if menu_items[m]["x64only"]:
					continue

			self._add_action(m, menu_items[m]["menu_str"], menu_items[m]["hotkey"], "DDR Tool", DDR_ida_action_handler(menu_items[m]["ah_id"]))

		# attach action to 'File/Load file/' menu
		result = idaapi.attach_action_to_menu(
			"File/Load file/",      # Relative path of where to add the action
			"DDR_Action_Load_file", # The action ID (see above)
			idaapi.SETMENU_APP      # We want to append the action after ^
		)
		if not result:
			idaapi.warning("[DDR] Failed to attach action (DDR_Action_Load_file) to main menu")
		else:
			DDR_print_mesg("Attached [DDR_Action_Load_file] to main menu",7)

		# attach action(s) to the toolbar
		if idaapi.attach_action_to_toolbar("AnalysisToolBar", "DDR_Action_Load_file"):
			DDR_print_mesg("Action [DDR_Action_Load_file] attached to toolbar.",7)
		else:
			idaapi.warning("[DDR] Failed to attach action [DDR_Action_Load_file] to toolbar.")

		# attach action(s) to context menu
		class Hooks(idaapi.UI_Hooks):
			def finish_populating_tform_popup(self, form, popup):
				# register all menu items from global menu_item dict
				for m in menu_items:

					if menu_items[m]["hide_in_context"]:
						continue

					if arch_bits != 64 and menu_items[m]["x64only"]:
						continue

					self._add_ida_popup(m, form, popup, "DDR/" + menu_items[m]["submenu"])

			def _add_ida_popup(self, act_name, form, popup, menuname):
				"""
				Helper function to add a menu to the context menu in IDA if we are in the Disasm view
				"""
				
				if idaapi.get_tform_type(form) == idaapi.BWN_DISASM:
					DDR_print_mesg("we are in DISASM view.",7)
					if (idaapi.attach_action_to_popup(form, popup, act_name, menuname)):
						DDR_print_mesg("added [%s] to context menu." % act_name,7)
						pass
					else:
						idaapi.warning("[DDR] Failed to add [%s] to context menu." % act_name)

				else:
					DDR_print_mesg("we are NOT in DISASM view.",7)
					return False

				return True

		self.hooks = Hooks()
		if (self.hooks.hook()):
			DDR_print_mesg("All actions attached to context menu.",7)
		else:
			idaapi.warning("[DDR] Hooking context menu failed.")

		try:
			DDR_print_mesg("DDR plugin started and initalized.")
			#logger.info("DDR plugin started")
			#DDR_print_mesg("Using Logfile: " + ddr_logfilename)
  
		except Exception as e:
			idaapi.warning("[DDR] init failed.")
			#logger.exception("Exception details:")
			return idaapi.PLUGIN_SKIP

		# tell IDA to keep the plugin loaded (everything is okay)
		return idaapi.PLUGIN_KEEP

	def run(self, arg):
		"""
		This is called by IDA when this file is loaded as a script.
		"""
		idaapi.warning("[DDR] This plugin cannot be run as a script in IDA.")

	def update(self, ctx):
		return idaapi.AST_ENABLE_FOR_FORM if ctx.form_type == idaapi.BWN_DISASM else idaapi.AST_DISABLE_FOR_FORM

	def term(self):
		"""
		This is called by IDA when it is unloading the plugin.
		"""

		# unregister all menues
		for m in menu_items:

					if arch_bits != 64 and menu_items[m]["x64only"]:
						continue

					self._unregister_ida_action(m)

		try:
			DDR_print_mesg("plugin terminated.")
		except Exception as e:
			idaapi.warning("[DDR] Failed to cleanly unload DDR from IDA.")
			#logger.exception("Failed to cleanly unload DDR from IDA.")

	def _unregister_ida_action(self, act_name):
		"""
		Helper function to unregister an IDA action
		"""

		if idaapi.unregister_action(act_name):
			DDR_print_mesg("[%s] action unregistered from IDA." % act_name,7)
		else:
			idaapi.warning("Failed to unregister ({action_name}) action in IDA.".format(action_name=act_name)) 

	def _add_action(self, act_name, act_text, act_shortcut, act_tooltip, act_handler):
		"""
		Helper function to add an action description to IDA
		"""
		action_desc = idaapi.action_desc_t(
			act_name,                  # The action name
			act_text,                  # The action text
			act_handler,               # The action handler
			act_shortcut,              # Optional: action shortcut
			act_tooltip                # Optional: tooltip
									   # Optional: the action icon
		)

		# register the action with IDA
		result = idaapi.register_action(action_desc)
		if not result: 
			idaapi.warning("[DDR] Failed to register action({action_name}) with IDA".format(action_name=act_name))

class DDR_MyChoose2(idaapi.Choose2):
	""" Chooser2 class to display Strings and API calls views"""
	def __init__(self, title, items, flags=0, width=None, height=None, embedded=False, modal=False, columns=False):
		
		self.lines_n = []

		idaapi.Choose2.__init__(
			self,
			title,
			columns,
			flags = flags,
			width = width,
			height = height,
			embedded = embedded)
		self.n = 0
		self.items = items
		self.icon = -1
		#self.selcount = 0
		self.modal = modal
		#self.popup_names = ["Inzert", "Del leet", "Ehdeet", "Ree frech"]

	def OnClose(self):
		# Window closed
		DDR_print_mesg("Trace View window closed" , 7)
		pass

	def OnEditLine(self, n):
		# Click on "Edit.. menu"
		DDR_print_mesg("Not implemented.")

	def OnInsertLine(self):
		# Click on "Insert.. menu"
		DDR_print_mesg("Not implemented.")

	def OnDeleteLine(self, n):
		# Click on "Delete menu"
		del self.items[n]
		DDR_print_mesg("Line %d deleted." % n , 7)
		return n

	def OnRefresh(self, n):
		# Click on "Refresh menu"
		DDR_print_mesg("Trace View window refreshed %d" % n, 7)
		return n

	def OnSelectLine(self, n):
		# double click on line
		self.lines_n.append(n)
		DDR_print_mesg("Line: %d  Address: %s  Name:%s" % (n, str(self.items[n][0]), str(self.items[n][1])), 7)
		ea = int(self.items[n][1],16) 
		idc.Jump(ea)

	def OnGetLine(self, n):
		return self.items[n]

	def OnGetSize(self):
		n = len(self.items)
		return n

	def OnGetIcon(self, n):
		r = self.items[n]
		t = self.icon + r[1].count("*")
		return t

	def OnGetLineAttr(self, n):
		# Highlight line 1 in blue:
		if n in self.lines_n:
			self.highlight_line = False
			return [0xFF0000, 0]
		
		return

	def show(self):
		return self.Show(self.modal) >= 0


# --- For future use Tree View Class  ---
#
#  tree_window = CBaseTreeViewer()
#  tree_window.Show("TreeView Tab Name")
#
class DDR_CBaseTreeViewer(idaapi.PluginForm):
	def populate_tree(self):
		# Clear previous items
		self.tree.clear()

	def OnCreate(self, form):
		# Get parent widget
		self.parent = idaapi.PluginForm.FormToPyQtWidget(form)

		# Create tree control
		self.tree = QtWidgets.QTreeWidget()
		self.tree.setHeaderLabels(("TreeWindowSubName",))
		self.tree.setColumnWidth(0, 100)

		# Create layout
		layout = QtWidgets.QVBoxLayout()
		layout.addWidget(self.tree)

		TreeBranch1 = QtWidgets.QTreeWidgetItem(self.tree)
		TreeBranch1.setText(0, "TreeBranch1")
		TreeBranch1.ea = idc.BADADDR
		leaf1 = QtWidgets.QTreeWidgetItem(TreeBranch1)
		leaf1.setText(0, "%s %s %s" % ("Leaf1.0","Leaf1.1","Leaf1.2"))
		leaf1.ea = idc.BADADDR
		leaf2 = QtWidgets.QTreeWidgetItem(TreeBranch1)
		leaf2.setText(0, "%s %s %s" % ("Leaf2.0","Leaf2.1","Leaf2.2"))
		leaf2.ea = idc.BADADDR
		TreeBranch2 = QtWidgets.QTreeWidgetItem(self.tree)
		TreeBranch2.setText(0, "TreeBranch2")
		leaf3 = QtWidgets.QTreeWidgetItem(TreeBranch2)
		leaf3.setText(0, "%s %s %s" % ("Leaf3.0","Leaf3.1","Leaf3.2"))
		leaf3.ea = idc.BADADDR

		# Populate PluginForm
		self.parent.setLayout(layout)

	def Show(self, title):
		return idaapi.PluginForm.Show(self, title, options = idaapi.PluginForm.FORM_PERSIST)

